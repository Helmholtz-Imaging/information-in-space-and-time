<div class="neon-atlas-wrapper">
  
  <div class="controls-row">
    <div class="domain-filters" id="filter-container"></div>
  </div>

  <div class="viz-stage">
    <svg id="neon-plot" width="100%" height="900"></svg>
  </div>

</div>

<script>
const config = {
  colors: {
    'Health': '#ff2a6d',
    'Matter': '#05d9e8',
    'Earth & Environment': '#00ff9f',
    'Information': '#0099cc',
    'Space & Transport': '#ffb86c',
    'Default': '#888888'
  },
  axes: [
    { id: 'physics_carrier', label: 'PHYSICS', 
      values: ['Photon', 'Electron', 'Neutron', 'Magnetic Field', 'Acoustic', 'Mechanical', 'Gravitational Field'] },
    { id: 'mechanism', label: 'MECHANISM', 
      values: ['Excitation', 'Transmission', 'Active', 'Passive'] },
    { id: 'scale_spatial', label: 'SCALE', 
      values: ['Nano', 'Micro', 'Milli', 'Macro', 'Kilo', 'Cosmic'] },
    { id: 'topology', label: 'TOPOLOGY', 
      values: ['Raster (2D)', 'Voxel (3D)', 'Point Cloud', 'Graph/Relational', 'Sparse Events', 'Function/Model'] },
    { id: 'density', label: 'DENSITY', 
      values: ['Scalar', 'Vector', 'Tensor', 'Spectral', 'Complex', 'Graph'] }
  ]
};

let rawData = [];

fetch('imaging_atlas.csv')
  .then(r => r.text())
  .then(csv => {
    rawData = parseCSV(csv);
    rawData = [...new Map(rawData.map(item => [item.name, item])).values()];
    rawData.sort((a, b) => {
      const pa = config.axes[0].values.indexOf(a.physics_carrier);
      const pb = config.axes[0].values.indexOf(b.physics_carrier);
      const primaryA = pa === -1 ? Number.MAX_SAFE_INTEGER : pa;
      const primaryB = pb === -1 ? Number.MAX_SAFE_INTEGER : pb;
      if (primaryA !== primaryB) return primaryA - primaryB;
      return a.name.localeCompare(b.name);
    });
    renderNeonPlot(rawData);
    
    // Handle window resize with debouncing
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        const svg = document.getElementById('neon-plot');
        if (svg) {
          // Clear existing content
          svg.innerHTML = '';
          renderNeonPlot(rawData);
        }
      }, 250);
    });
  });

function parseCSV(csvText) {
  const lines = csvText.split('\n').filter(l => l.trim().length > 0);
  return lines.slice(1).map(line => {
    const parts = line.match(/(".*?"|[^",]+)(?=\s*,|\s*$)/g) || [];
    const clean = parts.map(p => p.replace(/"/g, '').trim());
    // Normalize domains (merge legacy 'Space' and 'Transport' into 'Space & Transport')
    let domain = clean[1];
    if (domain === 'Space' || domain === 'Transport' || domain === 'Space&Transport') {
      domain = 'Space & Transport';
    }
    // Normalize density: merge detailed vector into Vector
    let density = clean[6];
    if (density === 'Vector (x,y,t,p)') {
      density = 'Vector';
    }
    // Normalize topology: treat Mesh as Point Cloud
    let topology = clean[5];
    if (topology === 'Mesh') {
      topology = 'Point Cloud';
    }
    return {
      name: clean[0],
      domain,
      physics_carrier: clean[2],
      scale_spatial: clean[4],
      topology,
      density,
      mechanism: clean[7],
      description: clean[9]
    };
  });
}

function renderNeonPlot(data) {
  const svg = document.getElementById('neon-plot');
  const rowHeight = 32; 
  const minHeight = 600;
  const calcHeight = Math.max(minHeight, (data.length * rowHeight) + 100);
  svg.setAttribute('height', calcHeight);

  const containerWidth = svg.parentElement.clientWidth;
  const minWidth = 1200; // Minimum required width
  const width = Math.max(containerWidth, minWidth);
  svg.setAttribute('width', width);
  svg.style.minWidth = minWidth + 'px';
  
  // Responsive margins - scale down on smaller screens
  const scaleFactor = Math.min(1, containerWidth / minWidth);
  const baseMargin = { top: 60, right: 80, bottom: 40, left: 520 };
  const margin = {
    top: baseMargin.top * scaleFactor,
    right: baseMargin.right * scaleFactor,
    bottom: baseMargin.bottom * scaleFactor,
    left: Math.max(300, baseMargin.left * scaleFactor)
  };
  
  const w = width - margin.left - margin.right;
  const h = calcHeight - margin.top - margin.bottom;

  // Scales
  const xStep = w / (config.axes.length - 1);
  const getX = (axisIdx) => margin.left + (axisIdx * xStep);

  const yScales = {};
  config.axes.forEach(axis => {
    yScales[axis.id] = (val) => {
      let idx = axis.values.indexOf(val);
      if (idx === -1) idx = axis.values.length; 
      const step = h / (axis.values.length); 
      return margin.top + (idx * step) + (step/2);
    };
  });

  const getNameY = (index) => margin.top + (index * (h / data.length));

  // 0. DEFINE SVG FILTERS (for blurred white borders)
  const defs = createSVG(svg, 'defs', {});
  // Blur filter for axis labels - creates blurry white border by blurring the white stroke
  const blurFilter = createSVG(defs, 'filter', { id: 'blur-shadow', x: '-50%', y: '-50%', width: '200%', height: '200%' });
  // Blur the entire element (including white stroke) to create blurry white border effect
  const blurBlur = createSVG(blurFilter, 'feGaussianBlur', { in: 'SourceGraphic', stdDeviation: '2', result: 'blurred' });
  const blurMerge = createSVG(blurFilter, 'feMerge', {});
  createSVG(blurMerge, 'feMergeNode', { in: 'blurred' });
  createSVG(blurMerge, 'feMergeNode', { in: 'SourceGraphic' });
  
  // Blur filter for tick labels - creates blurry white border by blurring the white stroke
  const blurFilterTick = createSVG(defs, 'filter', { id: 'blur-shadow-tick', x: '-50%', y: '-50%', width: '200%', height: '200%' });
  const blurBlurTick = createSVG(blurFilterTick, 'feGaussianBlur', { in: 'SourceGraphic', stdDeviation: '3', result: 'blurred' });
  const blurMergeTick = createSVG(blurFilterTick, 'feMerge', {});
  createSVG(blurMergeTick, 'feMergeNode', { in: 'blurred' });
  createSVG(blurMergeTick, 'feMergeNode', { in: 'SourceGraphic' });

  // 1. BACKGROUND AXES
  config.axes.forEach((axis, i) => {
    const x = getX(i);
    createSVG(svg, 'line', { x1: x, y1: margin.top, x2: x, y2: margin.top + h, class: 'axis-line' });
  });

  // 2. RIBBONS (smooth, interactive, variable thickness)
  // Calculate label height based on typical font size and spacing
  const labelHeight = 18; // Approximate label height in pixels
  
  data.forEach((item, idx) => {
    const color = config.colors[item.domain] || config.colors['Default'];
    const startY = getNameY(idx);
    const textGap = margin.left; // Increased gap for more space between names and physics labels
    const textX = margin.left - textGap;
    const ribbonStartX = textX; // Start at left edge of name labels
    const ribbonEndX = getX(config.axes.length - 1) + 80; // Extend beyond last axis to cover density labels

    // Calculate centerline points and ribbon thickness at each axis
    const centers = [];
    const halfHeights = [];
    const axisXs = [];
    const nameHalf = labelHeight; // Ribbon is thicker at the modality name

    config.axes.forEach((axis, axIdx) => {
      const x = getX(axIdx);
      axisXs[axIdx] = x;
      let y;
      let half = labelHeight / 2; // Ribbon hugs the label height

      if (axis.id === 'scale_spatial') {
        const vals = axis.values;
        const raw = item.scale_spatial || '';
        let startIdx = -1;
        let endIdx = -1;
        if (raw.includes('-')) {
          const parts = raw.split('-').map(p => p.trim());
          startIdx = vals.indexOf(parts[0]);
          endIdx = vals.indexOf(parts[1]);
        } else {
          startIdx = endIdx = vals.indexOf(raw);
        }
        if (startIdx === -1 || endIdx === -1) {
          startIdx = endIdx = vals.length;
        }
        const step = h / (vals.length);
        const topIdx = Math.min(startIdx, endIdx);
        const bottomIdx = Math.max(startIdx, endIdx) + 1;
        const centerIdx = (topIdx + bottomIdx) / 2;
        y = margin.top + centerIdx * step;
        
        // If it's a range, span the full range; if single value, hug the label
        if (startIdx === endIdx) {
          half = labelHeight / 2; // Single value: hug the label
        } else {
          half = (bottomIdx - topIdx) * step / 2; // Range: span the full range
        }
      } else {
        y = yScales[axis.id](item[axis.id]);
      }

      centers[axIdx] = y;
      halfHeights[axIdx] = half;
    });

    // Build smooth ribbon path: top edge forward, then bottom edge backward
    let ribbonD = '';
    
    // Calculate first axis values once
    const firstX = axisXs[0];
    const firstY = centers[0];
    const firstHalf = halfHeights[0];
    
    // Estimate text width (roughly 8-9px per character for monospace font at 15px size)
    const estimatedCharWidth = 8.5;
    const nameWidth = item.name.length * estimatedCharWidth;
    const nameEndX = textX + nameWidth + 10; // Add padding for safety
    
    // Start at top-left (hugging the name label, at left edge)
    ribbonD += `M ${ribbonStartX} ${startY - nameHalf}`;
    
    // Straight horizontal segment covering the full name width
    ribbonD += ` L ${nameEndX} ${startY - nameHalf}`;
    
    // Smooth curve from end of name to first axis (physics)
    const curveStartX = nameEndX;
    const cp1xTop = curveStartX + (firstX - curveStartX) * 0.5;
    const cp2xTop = curveStartX + (firstX - curveStartX) * 0.5;
    ribbonD += ` C ${cp1xTop} ${startY - nameHalf}, ${cp2xTop} ${firstY - firstHalf}, ${firstX} ${firstY - firstHalf}`;
    
    // Top edge: follow Bezier curves forward through remaining axes
    for (let axIdx = 1; axIdx < config.axes.length; axIdx++) {
      const x = axisXs[axIdx];
      const y = centers[axIdx];
      const half = halfHeights[axIdx];
      const prevX = axisXs[axIdx - 1];
      const prevY = centers[axIdx - 1];
      const prevHalf = halfHeights[axIdx - 1];
      
      // Control points for smooth Bezier curves
      const cp1x = prevX + (x - prevX) * 0.5;
      const cp2x = prevX + (x - prevX) * 0.5;
      
      // Top edge curve
      ribbonD += ` C ${cp1x} ${prevY - prevHalf}, ${cp2x} ${y - half}, ${x} ${y - half}`;
    }
    
    // Extend to right edge (beyond last axis to cover density labels)
    const lastIdx = config.axes.length - 1;
    const lastX = axisXs[lastIdx];
    const lastY = centers[lastIdx];
    const lastHalf = halfHeights[lastIdx];
    // Smooth curve from last axis to right edge
    const cp1xRight = lastX + (ribbonEndX - lastX) * 0.5;
    const cp2xRight = lastX + (ribbonEndX - lastX) * 0.5;
    ribbonD += ` C ${cp1xRight} ${lastY - lastHalf}, ${cp2xRight} ${lastY - lastHalf}, ${ribbonEndX} ${lastY - lastHalf}`;
    
    // Go straight down at the right edge
    ribbonD += ` L ${ribbonEndX} ${lastY + lastHalf}`;
    
    // Smooth curve from right edge back to last axis
    ribbonD += ` C ${cp2xRight} ${lastY + lastHalf}, ${cp1xRight} ${lastY + lastHalf}, ${lastX} ${lastY + lastHalf}`;
    
    // Bottom edge: follow Bezier curves backward through axes
    for (let axIdx = config.axes.length - 2; axIdx >= 0; axIdx--) {
      const x = axisXs[axIdx];
      const y = centers[axIdx];
      const half = halfHeights[axIdx];
      const nextX = axisXs[axIdx + 1];
      const nextY = centers[axIdx + 1];
      const nextHalf = halfHeights[axIdx + 1];
      
      // Control points (reversed for smooth backward curve)
      const cp1x = x + (nextX - x) * 0.5;
      const cp2x = x + (nextX - x) * 0.5;
      
      // Bottom edge curve (backward)
      ribbonD += ` C ${cp1x} ${nextY + nextHalf}, ${cp2x} ${y + half}, ${x} ${y + half}`;
    }
    
    // Smooth curve from first axis back to end of name
    const cp1xBottom = curveStartX + (firstX - curveStartX) * 0.5;
    const cp2xBottom = curveStartX + (firstX - curveStartX) * 0.5;
    ribbonD += ` C ${cp1xBottom} ${firstY + firstHalf}, ${cp2xBottom} ${startY + nameHalf}, ${nameEndX} ${startY + nameHalf}`;
    
    // Straight horizontal segment back to start (left edge)
    ribbonD += ` L ${ribbonStartX} ${startY + nameHalf} Z`;

    // Create the ribbon path
    const ribbon = createSVG(svg, 'path', {
      d: ribbonD,
      class: 'data-ribbon highlighted',
      fill: color,
      'fill-opacity': '0.4',
      stroke: 'none',
      'data-domain': item.domain,
      'data-id': idx
    });

    // Entrance animation
    const length = ribbon.getTotalLength();
    ribbon.style.strokeDasharray = length;
    ribbon.style.strokeDashoffset = length;
    ribbon.style.fillOpacity = '0';
    ribbon.getBoundingClientRect();
    setTimeout(() => {
      ribbon.style.strokeDashoffset = '0';
      ribbon.style.fillOpacity = '0.4';
    }, idx * 10);
    
    attachEvents(ribbon, item, color, idx);
  });

  // 3. LABELS
  config.axes.forEach((axis, i) => {
    const x = getX(i);
    const axisLabel = createSVG(svg, 'text', { x: x, y: margin.top - 25, class: 'axis-label', filter: 'url(#blur-shadow)' });
    axisLabel.textContent = axis.label;
    axis.values.forEach(val => {
      const y = yScales[axis.id](val);
      const tick = createSVG(svg, 'text', { x: x, y: y + 4, class: 'tick-label', 'text-anchor': 'middle', filter: 'url(#blur-shadow-tick)' });
      tick.textContent = val;
      tick.addEventListener('mouseenter', () => highlightByAxisValue(axis.id, val));
      tick.addEventListener('mouseleave', clearHover);
    });
  });

  // Name Labels
  data.forEach((item, idx) => {
    const startY = getNameY(idx);
    const textX = Math.max(10, margin.left * 0.04); // Responsive positioning
    
    const textEl = createSVG(svg, 'text', {
      x: textX, 
      y: startY,
      class: 'name-label',
      'text-anchor': 'start',
      'data-id': idx,
      'data-domain': item.domain 
    });
    textEl.textContent = item.name;
    
    const color = config.colors[item.domain] || config.colors['Default'];
    attachEvents(textEl, item, color, idx);
  });

  buildFilters(data);
}

function attachEvents(el, item, color, idx) {
  const triggerHover = (e) => {
    document.querySelectorAll('.data-ribbon').forEach(r => r.classList.add('dimmed'));
    document.querySelectorAll('.name-label').forEach(l => l.style.opacity = 0.3);
    
    const ribbon = document.querySelector(`.data-ribbon[data-id="${idx}"]`);
    const label = document.querySelector(`.name-label[data-id="${idx}"]`);
    
    if (ribbon) {
      ribbon.classList.remove('dimmed');
      ribbon.classList.add('active-hover');
    }
    if (label) {
      label.style.opacity = 1;
      label.style.fill = '#000';
    }
    
    showTooltip(e, item, color);
  };

  el.addEventListener('mouseenter', triggerHover);
  el.addEventListener('mouseleave', clearHover);
}

function highlightByAxisValue(axisId, value) {
  document.querySelectorAll('.data-ribbon').forEach(r => r.classList.add('dimmed'));
  document.querySelectorAll('.name-label').forEach(l => {
    l.style.opacity = 0.3;
    l.style.fill = '#666';
  });

  rawData.forEach((item, idx) => {
    let shouldHighlight = false;
    
    if (axisId === 'scale_spatial') {
      // For scale, check if value is in the range or matches exactly
      const raw = item.scale_spatial || '';
      if (raw.includes('-')) {
        // It's a range - check if the hovered value is within the range
        const parts = raw.split('-').map(p => p.trim());
        const scaleAxis = config.axes.find(ax => ax.id === 'scale_spatial');
        if (scaleAxis) {
          const vals = scaleAxis.values;
          const hoverIdx = vals.indexOf(value);
          const startIdx = vals.indexOf(parts[0]);
          const endIdx = vals.indexOf(parts[1]);
          if (hoverIdx !== -1 && startIdx !== -1 && endIdx !== -1) {
            const minIdx = Math.min(startIdx, endIdx);
            const maxIdx = Math.max(startIdx, endIdx);
            shouldHighlight = (hoverIdx >= minIdx && hoverIdx <= maxIdx);
          }
        }
      } else {
        // Single value - exact match
        shouldHighlight = (item[axisId] === value);
      }
    } else {
      // For other axes, exact match
      shouldHighlight = (item[axisId] === value);
    }
    
    if (shouldHighlight) {
      const ribbon = document.querySelector(`.data-ribbon[data-id="${idx}"]`);
      const label = document.querySelector(`.name-label[data-id="${idx}"]`);
      if (ribbon) {
        ribbon.classList.remove('dimmed');
        ribbon.classList.add('active-hover');
      }
      if (label) {
        label.style.opacity = 1;
        label.style.fill = '#000';
      }
    }
  });
}

function createSVG(parent, type, attrs) {
  const el = document.createElementNS('http://www.w3.org/2000/svg', type);
  for (let k in attrs) el.setAttribute(k, attrs[k]);
  parent.appendChild(el);
  return el;
}

function buildFilters(data) {
  const domains = [...new Set(data.map(d => d.domain))].sort();
  const filterBox = document.getElementById('filter-container');
  filterBox.innerHTML = ''; 
  
  const allBtn = document.createElement('button');
  allBtn.className = 'filter-pill active';
  allBtn.textContent = 'All';
  allBtn.onclick = () => filterGraph('all', allBtn);
  filterBox.appendChild(allBtn);

  domains.forEach(d => {
    const btn = document.createElement('button');
    btn.className = 'filter-pill';
    btn.textContent = d;
    btn.style.color = config.colors[d] || '#888';
    btn.onclick = () => filterGraph(d, btn);
    filterBox.appendChild(btn);
  });
}

function filterGraph(domain, btn) {
  document.querySelectorAll('.filter-pill').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  
  const ribbons = document.querySelectorAll('.data-ribbon');
  const labels = document.querySelectorAll('.name-label');

  const updateVisibility = (elements, isText) => {
    elements.forEach(el => {
      const d = el.getAttribute('data-domain');
      const shouldShow = (domain === 'all' || d === domain);
      
      if (shouldShow) {
        if (isText) el.classList.remove('text-faded-out');
        else el.classList.remove('faded-out');
      } else {
        if (isText) el.classList.add('text-faded-out');
        else el.classList.add('faded-out');
      }
    });
  };

  updateVisibility(ribbons, false);
  updateVisibility(labels, true);
}

const tooltip = document.getElementById('neon-tooltip');

function showTooltip(e, item, color) {
  tooltip.style.display = 'block';
  requestAnimationFrame(() => {
    tooltip.classList.add('tooltip-visible');
  });
  
  tooltip.style.borderColor = color;
  tooltip.innerHTML = `
    <strong style="color:${color}; font-size: 0.9rem;">${item.name}</strong>
    <div style="margin-top:2px; color:#666; font-size:0.65rem;">${item.domain.toUpperCase()}</div>
    <hr style="border:0; border-top:1px solid #ccc; margin:6px 0;">
    <div style="line-height:1.3; color:#333;">${item.description}</div>
  `;
  
  const tooltipWidth = 280; 
  const mouseX = e.pageX;
  const mouseY = e.pageY;
  const windowWidth = window.innerWidth;
  
  if (mouseX > windowWidth * 0.6) {
    tooltip.style.left = (mouseX - tooltipWidth - 20) + 'px';
  } else {
    tooltip.style.left = (mouseX + 20) + 'px';
  }
  tooltip.style.top = (mouseY + 20) + 'px';
}

function clearHover() {
  document.querySelectorAll('.data-ribbon').forEach(r => {
    r.classList.remove('dimmed');
    r.classList.remove('active-hover');
  });
  document.querySelectorAll('.name-label').forEach(l => {
    l.style.opacity = 1;
    l.style.fill = '#000'; 
  });
  
  tooltip.classList.remove('tooltip-visible');
  setTimeout(() => {
    if (!tooltip.classList.contains('tooltip-visible')) {
      tooltip.style.display = 'none';
    }
  }, 200);
}
</script>